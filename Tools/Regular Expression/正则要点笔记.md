# 正则要点笔记

## 环视

|    描述     | regex    |
| :---------: | :------- |
| 肯定顺序环视 | (?=...)  |
| 肯定逆序环视 | (?<=...) |
| 否定顺序环视 | (?!...)  |
| 否定逆序环视 | (?<!...) |

### 要点

环视不会“占用”字符，其匹配的是一个位置。  

### 示例

#### 单个顺序环视以及用顺序环视匹配单词的一部分

>例1：
> ```regex
> (?Jeffrey)
> ```
> 一个匹配示例：
> ![肯定顺序环视的匹配示例](_v_images/20200229090033210_1407.png =233x)
> 即右边紧跟一个`Jeffrey`字符序列的位置

>例2：
>```regex
>(?Jeffrey)Jeff
># 因为顺序环视只匹配位置，所以这个表达式两部分顺序调换后仍等价
>Jeff(?Jeffrey)
>```
>一个匹配示例：
>![用肯定顺序环视精确匹配单词的一部分](_v_images/20200229090535431_3450.png =233x)
>![](_v_images/20200229090628507_31810.png =233x)
>即匹配`Jeffrey`中的`Jeff`
>![肯定顺序环视细节描述](_v_images/20200229091409927_18349.png =400x)

#### 用环视在字符序列中添加符号(在Perl中）

> 例1：
> 在`Jeffs`中插入一个`'`
> ```perl
> s/(?<=\bJeff)(?=s\b)/'/g
> # 同样，这个表达式颠倒一下仍然等效
> s/(?=s\b)(?<=\bJeff)/'/g
> ```
> ![用顺序环视在字符序列中插入符号](_v_images/20200229092440005_23129.png =400x)

#### 用环视表示单词边界符

```regex
# 单词起始分界(左侧不是\w右侧是\w)
(?<!\w)(?=\w)
# 单词结束分界(左侧是\w右侧不是\w)
(?<=\w)(?!\w)
# 单词分界(起始或结束等价于\b)
(?<!\w)(?=\w)|(?<=\w)(?!\w)
```

## 在某种特定的宿主语言或工具中使用正则时需要注意的问题

### 正则表达式的流派(flavor)

支持的元字符以及元字符的意义  

### 正则表达式与语言或工具的交互方式

如何进行正则表达式操作，容许哪些操作，以及操作的目标文本类型  


### 正则表达式的实现方法

### 细节问题
![](_v_images/20200306182434609_6146.png =400x)
![](_v_images/20200306182505815_11100.png =400x)

## 程序设计语言对正则表达式的处理方式

### 集成式处理

正则表达式直接内建在语言之中  

#### Perl

```Perl
if ($line =~ s/^Subject:(.*)/i) {
    $subject = $1;
}
```

### 程序式处理

#### Java

正则功能由普通函数，构造函数，方法来提供  

```java
if (! Pattern.matches("\\s*", line))
{
    // ...如果line不是空行...
}
```

> `Pattern.matches`函数包装了一个`^...$`的正则表达式，返回一个布尔值

#### VB.NET

```VB.NET
IF Not Regex.IsMatch(Line, "^\s*$") Then
    '... 如果line不是空行 ...
END IF
```

#### PHP

```php
if (preg_match('/^Subject:(.*)/i', $line, $matches))
    $Subject = $matches[1];
```

### 面向对象式处理

#### Java

```java
import java.util.regex.*;
    ...
Pattern r = Pattern.compile("^Subject:(.*)", Pattern.CASE_INSENSITIVE);  //1
Matcher m = r.matcher(line);                                             //2
if (m.find()) {                                                          //3
    subject = m.group(1);                                                //4
}
```

> //1: 检查正则表达式，将它编译为能进行不区分大小写的匹配的内部形式(internal form)，得到一个"Pattern"对象
> //2: 将它与欲匹配文本联系，得到一个"Matcher"对象
> //3: 应用正则表达式，检查之前与之建立联系的文本，检查是否存在匹配，返回结果
> //4: 如果存在匹配，提取第一个捕获括号内的子表达式匹配的文本

#### VB.NET

```VB.NET
Imports System.Text.RegularExpressions
    ...
Dim R as Regex = New Regex("^Subject:(.*)", RegexOptions.IgnoreCase)
Dim M as Match = R.Match(line)
If M.Success
    subject = M.Groups(1).Value
End IF
```

#### Python

```python
import re;
    ...
R = re.compile("^Subject:(.*)", re.IGNORECASE);
M = R.search(line)
if M:
    subject = M.group(1)
```

## 作为正则表达式的字符串

在构造作为正则表达式的字符串时，需要留意编程语言定义的字符串元字符  
即要留意：在编程语言的字符串处理结束后，正则引擎接收到的是什么  

### Java的字符串

字符串标注：双引号`"..."`
元字符：       反斜线`\`
常见转义序列：`\t` `\n` `\\`
字符串中出现未获支持的转义序列会报错  

### VB.NET的字符串

字符串标注: 双引号`"..."`
元字符：     双引号`"`
转义序列：  `""`(代表双引号)
> `"he said ""hi""\."` 的值是 `he said "hi"\.`

### C#的字符串

1. 双引号字符串
    字符串标注：双引号`"..."`
    元字符：       反斜线`\`
    常见转义序列： `\"` (表示双引号)

2. 原生字符串(verbatim string)
    字符串标注：`@"..."`
    转义序列    ：`""` (表示双引号)(不能识别反斜线转义序列)
    > `"\\t\\x2A"`和`@"\t\x2A"`都可以生成`\t\x2A`
    > 转义序列`\x2A`代表`*`字符，这里在双引号字符串使用另一个转义序列`\\`来防止使用这个转义序列
    > 因为原生字符串的特性，一般在C#中用这种方式表示正则

字符串中出现未获支持的转义序列会报错  

### PHP的字符串

1. 双引号字符串
    字符串标注：双引号`"..."`
    支持常见的反斜线序列(`\t`,`\n`,`\\`)，变量插值，`{...}`序列插入代码执行结果  
    字符串中出现未获支持的转义序列会将其识别为普通字符序列  

2. 单引号字符串
    字符串标注：单引号`'...'`
    转义序列   ：`\'`, `\\`
    除转义序列以外的其他任何字符都不会被识别为特殊字符  
    <span style="color:orange">单引号字符串里反斜线都不需要转义那`\\`是怎么回事？</span>  
    > `'\t\x2A'` 创建 `\t\x2A`
    > PHP中通常用单引号字符串来表示正则

### Python的字符串

1. 双引号字符串和单引号字符串以及对应的三重引用字符串
    单引号和双引号两种方法没有区别  
    三重引用可以包含未转义的换行符<span style="color:orange">换行符当成普通字符序列？</span>  
    字符串标注：双引号或单引号`"..."`, `'...'`, `'''...'''`, `""",,,"""`  
    支持常用的转义序列，会把不能识别的转义序列作为普通字符序列对待  

2. 原字符串(raw string)
    字符串标注：在以上四种表示法前加`r`
    特点：原字符串内所有反斜线都保留  
    > `r"he said \"hi\"\."` 表示 `he said \"hi\"\.`  

### Tcl中的字符串

Tcl没有真正的字符串变量，命令行被分解成"单词"，所以常见的反斜线转义序列能够识别和转换，无法识别的将会被忽略  
可以在单词两端添加双引号，只有单词中间存在空格时才是必须的  

**原字符串**
字符串标记：`{...}`  
除`\n`以外的所有内容都作为普通字符序列  
> `{\t\x2A}` 表示 `\t\x2A`

### Perl的正则表达式文字

在Perl中使用正则可以以文字(正则表达式文字)或字符串变量的方式  
> `$str =~ m/(\w+)/;`
> 可以
> `$regex = '(\w+)';` <span style="color:orange">为什么不用qr</span>
> `$str =~ $regex;`
> 可以
> `$regex = "(\\w+)";` <span style="color:orange">单引号和双引号的区别是什么</span>
> `$str =~ $regex;`

以文字方式提交正则表达式会有额外特性，而使用字符串可能大大降低效率

* 变量插值
* 通过`\Q...\E`支持文字文本
* 支持`\N{name}`结构，可以通过Unicode名指定字符








