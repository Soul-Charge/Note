# 正则要点笔记

## 环视

|    描述     | regex    |
| :---------: | :------- |
| 肯定顺序环视 | (?=...)  |
| 肯定逆序环视 | (?<=...) |
| 否定顺序环视 | (?!...)  |
| 否定逆序环视 | (?<!...) |

### 要点

环视不会“占用”字符，其匹配的是一个位置。  

### 示例

#### 单个顺序环视以及用顺序环视匹配单词的一部分

>例1：
> ```regex
> (?Jeffrey)
> ```
> 一个匹配示例：
> ![肯定顺序环视的匹配示例](_v_images/20200229090033210_1407.png =233x)
> 即右边紧跟一个`Jeffrey`字符序列的位置

>例2：
>```regex
>(?Jeffrey)Jeff
># 因为顺序环视只匹配位置，所以这个表达式两部分顺序调换后仍等价
>Jeff(?Jeffrey)
>```
>一个匹配示例：
>![用肯定顺序环视精确匹配单词的一部分](_v_images/20200229090535431_3450.png =233x)
>![](_v_images/20200229090628507_31810.png =233x)
>即匹配`Jeffrey`中的`Jeff`
>![肯定顺序环视细节描述](_v_images/20200229091409927_18349.png =400x)

#### 用环视在字符序列中添加符号(在Perl中）

> 例1：
> 在`Jeffs`中插入一个`'`
> ```perl
> s/(?<=\bJeff)(?=s\b)/'/g
> # 同样，这个表达式颠倒一下仍然等效
> s/(?=s\b)(?<=\bJeff)/'/g
> ```
> ![用顺序环视在字符序列中插入符号](_v_images/20200229092440005_23129.png =400x)

#### 用环视表示单词边界符

```regex
# 单词起始分界(左侧不是\w右侧是\w)
(?<!\w)(?=\w)
# 单词结束分界(左侧是\w右侧不是\w)
(?<=\w)(?!\w)
# 单词分界(起始或结束等价于\b)
(?<!\w)(?=\w)|(?<=\w)(?!\w)
```

## 在某种特定的宿主语言或工具中使用正则时需要注意的问题

### 正则表达式的流派(flavor)

支持的元字符以及元字符的意义  

### 正则表达式与语言或工具的交互方式

如何进行正则表达式操作，容许哪些操作，以及操作的目标文本类型  


### 正则表达式的实现方法

### 细节问题
![](_v_images/20200306182434609_6146.png =400x)
![](_v_images/20200306182505815_11100.png =400x)

## 程序设计语言对正则表达式的处理方式

### 集成式处理

正则表达式直接内建在语言之中  

#### Perl

```Perl
if ($line =~ s/^Subject:(.*)/i) {
    $subject = $1;
}
```

### 程序式处理

#### Java

正则功能由普通函数，构造函数，方法来提供  

```java
if (! Pattern.matches("\\s*", line))
{
    // ...如果line不是空行...
}
```

> `Pattern.matches`函数包装了一个`^...$`的正则表达式，返回一个布尔值

#### VB

```VB
IF Not Regex.IsMatch(Line, "^\s*$") Then
    '... 如果line不是空行 ...
END IF
```

#### PHP

```php
if (preg_match('/^Subject:(.*)/i', $line, $matches))
    $Subject = $matches[1];
```

### 面向对象式处理

#### Java

```java
import java.util.regex.*;
    ...
Pattern r = Pattern.compile("^Subject:(.*)", Pattern.CASE_INSENSITIVE);  //1
Matcher m = r.matcher(line);                                             //2
if (m.find()) {                                                          //3
    subject = m.group(1);                                                //4
}
```

> //1: 检查正则表达式，将它编译为能进行不区分大小写的匹配的内部形式(internal form)，得到一个"Pattern"对象
> //2: 将它与欲匹配文本联系，得到一个"Matcher"对象
> //3: 应用正则表达式，检查之前与之建立联系的文本，检查是否存在匹配，返回结果
> //4: 如果存在匹配，提取第一个捕获括号内的子表达式匹配的文本

#### VB

```VB
Imports System.Text.RegularExpressions
    ...
Dim R as Regex = New Regex("^Subject:(.*)", RegexOptions.IgnoreCase)
Dim M as Match = R.Match(line)
If M.Success
    subject = M.Groups(1).Value
End IF
```

#### Python

```python
import re;
    ...
R = re.compile("^Subject:(.*)", re.IGNORECASE);
M = R.search(line)
if M:
    subject = M.group(1)
```





