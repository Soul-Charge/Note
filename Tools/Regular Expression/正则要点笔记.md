# 正则要点笔记

## 环视

|    描述     | regex    |
| :---------: | :------- |
| 肯定顺序环视 | (?=...)  |
| 肯定逆序环视 | (?<=...) |
| 否定顺序环视 | (?!...)  |
| 否定逆序环视 | (?<!...) |

### 要点

环视不会“占用”字符，其匹配的是一个位置。  

### 示例

#### 单个顺序环视以及用顺序环视匹配单词的一部分

>例1：
> ```regex
> (?Jeffrey)
> ```
> 一个匹配示例：
> ![肯定顺序环视的匹配示例](_v_images/20200229090033210_1407.png =233x)
> 即右边紧跟一个`Jeffrey`字符序列的位置

>例2：
>```regex
>(?Jeffrey)Jeff
># 因为顺序环视只匹配位置，所以这个表达式两部分顺序调换后仍等价
>Jeff(?Jeffrey)
>```
>一个匹配示例：
>![用肯定顺序环视精确匹配单词的一部分](_v_images/20200229090535431_3450.png =233x)
>![](_v_images/20200229090628507_31810.png =233x)
>即匹配`Jeffrey`中的`Jeff`
>![肯定顺序环视细节描述](_v_images/20200229091409927_18349.png =400x)

#### 用环视在字符序列中添加符号(在Perl中）

> 例1：
> 在`Jeffs`中插入一个`'`
> ```perl
> s/(?<=\bJeff)(?=s\b)/'/g
> # 同样，这个表达式颠倒一下仍然等效
> s/(?=s\b)(?<=\bJeff)/'/g
> ```
> ![用顺序环视在字符序列中插入符号](_v_images/20200229092440005_23129.png =400x)

#### 用环视表示单词边界符

```regex
# 单词起始分界(左侧不是\w右侧是\w)
(?<!\w)(?=\w)
# 单词结束分界(左侧是\w右侧不是\w)
(?<=\w)(?!\w)
# 单词分界(起始或结束等价于\b)
(?<!\w)(?=\w)|(?<=\w)(?!\w)
```

## 在某种特定的宿主语言或工具中使用正则时需要注意的问题

### 正则表达式的流派(flavor)

支持的元字符以及元字符的意义  

### 正则表达式与语言或工具的交互方式

如何进行正则表达式操作，容许哪些操作，以及操作的目标文本类型  


### 正则表达式的实现方法

### 细节问题
![](_v_images/20200306182434609_6146.png =400x)
![](_v_images/20200306182505815_11100.png =400x)

## 程序设计语言对正则表达式的处理方式

### 集成式处理

正则表达式直接内建在语言之中  

#### Perl

```Perl
if ($line =~ s/^Subject:(.*)/i) {
    $subject = $1;
}
```

### 程序式处理

#### Java

正则功能由普通函数，构造函数，方法来提供  

```java
if (! Pattern.matches("\\s*", line))
{
    // ...如果line不是空行...
}
```

> `Pattern.matches`函数包装了一个`^...$`的正则表达式，返回一个布尔值

#### VB.NET

```VB.NET
IF Not Regex.IsMatch(Line, "^\s*$") Then
    '... 如果line不是空行 ...
END IF
```

#### PHP

```php
if (preg_match('/^Subject:(.*)/i', $line, $matches))
    $Subject = $matches[1];
```

### 面向对象式处理

#### Java

```java
import java.util.regex.*;
    ...
Pattern r = Pattern.compile("^Subject:(.*)", Pattern.CASE_INSENSITIVE);  //1
Matcher m = r.matcher(line);                                             //2
if (m.find()) {                                                          //3
    subject = m.group(1);                                                //4
}
```

> //1: 检查正则表达式，将它编译为能进行不区分大小写的匹配的内部形式(internal form)，得到一个"Pattern"对象
> //2: 将它与欲匹配文本联系，得到一个"Matcher"对象
> //3: 应用正则表达式，检查之前与之建立联系的文本，检查是否存在匹配，返回结果
> //4: 如果存在匹配，提取第一个捕获括号内的子表达式匹配的文本

#### VB.NET

```VB.NET
Imports System.Text.RegularExpressions
    ...
Dim R as Regex = New Regex("^Subject:(.*)", RegexOptions.IgnoreCase)
Dim M as Match = R.Match(line)
If M.Success
    subject = M.Groups(1).Value
End IF
```

#### Python

```python
import re;
    ...
R = re.compile("^Subject:(.*)", re.IGNORECASE);
M = R.search(line)
if M:
    subject = M.group(1)
```

## 作为正则表达式的字符串

在构造作为正则表达式的字符串时，需要留意编程语言定义的字符串元字符  
即要留意：在编程语言的字符串处理结束后，正则引擎接收到的是什么  

### Java的字符串

字符串标注：双引号`"..."`
元字符：       反斜线`\`
常见转义序列：`\t` `\n` `\\`
字符串中出现未获支持的转义序列会报错  

### VB.NET的字符串

字符串标注: 双引号`"..."`
元字符：     双引号`"`
转义序列：  `""`(代表双引号)
> `"he said ""hi""\."` 的值是 `he said "hi"\.`

### C#的字符串

1. 双引号字符串
    字符串标注：双引号`"..."`
    元字符：       反斜线`\`
    常见转义序列： `\"` (表示双引号)

2. 原生字符串(verbatim string)
    字符串标注：`@"..."`
    转义序列    ：`""` (表示双引号)(不能识别反斜线转义序列)
    > `"\\t\\x2A"`和`@"\t\x2A"`都可以生成`\t\x2A`
    > 转义序列`\x2A`代表`*`字符，这里在双引号字符串使用另一个转义序列`\\`来防止使用这个转义序列
    > 因为原生字符串的特性，一般在C#中用这种方式表示正则

字符串中出现未获支持的转义序列会报错  

### PHP的字符串

1. 双引号字符串
    字符串标注：双引号`"..."`
    支持常见的反斜线序列(`\t`,`\n`,`\\`)，变量插值，`{...}`序列插入代码执行结果  
    字符串中出现未获支持的转义序列会将其识别为普通字符序列  

2. 单引号字符串
    字符串标注：单引号`'...'`
    转义序列   ：`\'`, `\\`
    除转义序列以外的其他任何字符都不会被识别为特殊字符  
    <span style="color:orange">单引号字符串里反斜线都不需要转义那`\\`是怎么回事？</span>  
    > `'\t\x2A'` 创建 `\t\x2A`
    > PHP中通常用单引号字符串来表示正则

### Python的字符串

1. 双引号字符串和单引号字符串以及对应的三重引用字符串
    单引号和双引号两种方法没有区别  
    三重引用可以包含未转义的换行符<span style="color:orange">换行符当成普通字符序列？</span>  
    字符串标注：双引号或单引号`"..."`, `'...'`, `'''...'''`, `""",,,"""`  
    支持常用的转义序列，会把不能识别的转义序列作为普通字符序列对待  

2. 原字符串(raw string)
    字符串标注：在以上四种表示法前加`r`
    特点：原字符串内所有反斜线都保留  
    > `r"he said \"hi\"\."` 表示 `he said \"hi\"\.`  

### Tcl中的字符串

Tcl没有真正的字符串变量，命令行被分解成"单词"，所以常见的反斜线转义序列能够识别和转换，无法识别的将会被忽略  
可以在单词两端添加双引号，只有单词中间存在空格时才是必须的  

**原字符串**
字符串标记：`{...}`  
除`\n`以外的所有内容都作为普通字符序列  
> `{\t\x2A}` 表示 `\t\x2A`

### Perl的正则表达式文字

在Perl中使用正则可以以文字(正则表达式文字)或字符串变量的方式  
> `$str =~ m/(\w+)/;`
> 可以
> `$regex = '(\w+)';` <span style="color:orange">为什么不用qr</span>
> `$str =~ $regex;`
> 可以
> `$regex = "(\\w+)";` <span style="color:orange">单引号和双引号的区别是什么</span>
> `$str =~ $regex;`

以文字方式提交正则表达式会有额外特性，而使用字符串可能大大降低效率

* 变量插值
* <a href="#toc_47">通过`\Q...\E`支持文字文本</a>
* 支持`\N{name}`结构，可以通过Unicode名指定字符

## 正则与字符编码

### 与编码相关的问题

* 程序能否识别某种编码？
* 程序如何决定使用何种编码来处理数据？
* 正则表达式对某种编码的支持程度？
    * 能否支持多字节字符？点号和`[^x]`之类的表达式匹配单个字符还是单个字节
    * `\w`, `\d`, `\s`, `\b`, 之类的元字符，是否能识别编码中的所有字符
        > ê也是一个字符，`\w`和`\b`能处理吗?
    * 程序是否会扩展对字符组的解释
        > `[a-z]`能否匹配ê?
    * 不区分大小写的匹配是否能对所有字符有效？
        > ê和&#202;是否一样？

### Unicode

#### Unicode 的概念

Unicode是一组数字和字符之间的逻辑映射的概念编码  
代码点：Ê对应数值50058，此数值称为一个代码点(code point)，通常用十六进制表示，以`U+`开头

\u**num**元序列
匹配编号为**num**的Unicode字符，**num**以`U+`开头
用来匹配一个具体的Unicode字符，num通常为一个4位的十六进制数
> `\uU+C38A`

#### 组合字符序列

在Unicode中，一个基本字符可能由多个代码点构成  
> à可能由`U+0061`和`U+0300`构成  

##### 给正则引擎带来的麻烦：匹配单个代码点还是多个代码点组成的组合字符

###### 单个代码点

许多程序把字符和代码点视为等价，即`.`可以匹配单个的代码点  
> à(U+0061加上U+0300)能由`^..$`匹配而不是`^.$`  
> `[à]`在字符组中添加了两个字符
> `à+`量词作用的是后面的抑音符(`)

###### 多个代码点

一些由多个代码点构成的字符也可能由单个代码点构成
> à转换为`U+6001和U+0300的组合`或`U+00E0`

**问题：可能无法从外观上区分字符**

* I(罗马字母`U+0049`)可能与I(希腊字母Iota`U+0399`)混淆
* ㎐(U+3309)看起来就很像两个普通字符`H`和`z`

#### Unicode 3.1+和U+FFFF之后的代码点

大多数程序的`\unum`只能支持最多四位十六进制数值，而能够处理之后的新字符的程序通常提供`\x{num}`序列
> `num`可为任意位数的数字(可兼容`\unum`表示)
> `\x{1D121}`匹配`𝄡`(C谱号)

#### Unicode 中的行终止符

![](_v_images/20200309174637777_19649.png =400x)
如果行终止符得到了完全的支持将会影响`.`, `^`, `$`， `\z`的匹配

## 正则模式和匹配模式

### 不区分大小写的匹配模式

#### 与Unicode相关的问题

* 大写和小写之间没有明显的一对一映射
    > `Σ` 有两个小写形式`σ`, `ς`
* 单一字符对应一组字符
    ![](_v_images/20200309183056216_21028.png =400x)
    <span style="color:orange">那个符号不知道是什么，也不懂什么意思，指前面提到的多代码点吗？</span>
* 字符在大小写的对应上没有相应的代码点对应
    > `ǰ` (U+01F0) 没有对应的大写形式的单字符，`J̌` 需要用组合字符`U+004A`和`U+030C`
    > <span style="color:green">第一个真的是小写，只是用了行内代码后看起来一样╮(╯-╰)╭</span>

### 宽松排列和注释模式

此模式会忽略字符组外部的所有空白字符，`#`和换行符之间的内容被视为注释  
在`java.util.regex`中，字符组之外的所有空白符并非都会被忽略，而是作为一个“无意义元字符”(do-nothing metacharacter)
> `\12 3`表示`3`接在`\12`后，而不是`\123`
> "空白字符"的定义取决于采用的编码，以及此编码对空白字符的支持程度，大多数程序只能识别ASCII的空白字符

### 点号通配模式

能处理多行文本的工具通常不容许`.`匹配换行符，但许多程序也提供了能匹配换行符的模式  
> 排除型字符组通常可以匹配换行符

Tcl的普通模式中`.`能匹配任何字符，但在其特殊的"区分换行"和"部分区分换行"的匹配模式下，`.`和排除型字符组都不能匹配换行符  
`/s`修饰符对应的"单行文本模式"：`.`可以匹配任何字符

#### 增强的行锚点模式(多行文本模式)

通常行锚点`^`和`$`不能匹配字符串内的换行符，只能匹配字符串的起始和结束位置，但在此模式下则可以
支持此模式的程序通常提供了`\A`和`\Z`，作用与普通的`^`和`$`一样，但在此模式下意义不会变化

#### 文字文本模式

将正则表达式匹配变成普通的字符串匹配
Perl中使用`\Q...\E`，其中的元字符被看作普通字符(不包括\E)