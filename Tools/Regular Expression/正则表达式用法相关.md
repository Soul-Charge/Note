# 正则表达式用法相关

## 在Perl中修正单词的大小写

```perl
$var =~ s/\bJeff/Jeff/i;
# 使用i选项使得匹配不区分大小写
# 例：
# jeff 变成 Jeff
# JEFF 变成 Jeff
# JeFf 变成 Jeff
```

## 在Perl中修改浮点数表示位数

通常保留小数点后两位，如果第三位不为零也保留。  

```perl
$price =~ s/(\.\d\d[1-9]?)\d*/$1/;
```

## 用Perl对文件进行修改

### 单行命令

```shell
perl -p -i -e 's/regx/text/g' file file2
# -p  : 对文件的每一行进行操作
# -i  : 将替换结果写回文件,不加此选项则命令会将结果回显但不改变文件
# -e  : 表示单行perl程序
#  g  : 一行中进行多次操作(类似于vim的替换操作的g)
# file: 要操作的文件
# file2: 可能的多个文件，也可以用*.txt等方式代替文件名
```

### 使用单独的脚本文件

```shell
# 在终端运行的命令
perl -w script.pl inputfile > outputfile
# script.pl  用来处理的脚本文件
# inputfile  需要处理的文件
# outputfile 处理结果输出的文件
```

```perl
# 脚本文件的写法
# $line = <> 会从inputfile中读取一行内容保存(保留换行符)到line变量中
wile ($line = <>) # 读取文件每一行，具体操作不是很明白，应该是当<>到达文件尾部返回一个假值
{
    处理$line...
}
```

### 将文件的全部内容放入单个变量

```perl
undef $/;   #进入文件读取模式
$text = <>; #读入命令行中指定的第一个文件
```

## 用Perl给数字添加逗号

### 使用环视

每三位数一个逗号。  

```perl
$val =~ s/(?<=\d)(?=(?:\d\d\d)+(?!\d))/,/g;
# 注意不能用\D 代替(?!\d)
# 因为\D 必须要匹配一个字符，而(?!\d)不匹配字符
```

### 只使用顺序环视

```perl
$val =~ s/(\d)(?=(\d\d\d)+(?!\d)/$1,/g;
```

### 不使用环视

```perl
while ($text =~ s/(\d)((\d\d\d)+\b)/$1,$2/g){
    # 循环内不用进行任何操作
}
```

## 用Perl将普通文本转换成HTML文本

### 处理HTML的特殊字符

```perl
$text =~ s/&/&amp;/g;
$text =~ s/</&lt;/g;
$text =~ s/>/&gt;/g;
# 用/g对所有目标字符进行替换
# 先转换&防止>和<的&也被转换
```

### 用`<p>`分隔文本段落

将空行替换成`<p>`  

```perl
$text =~ s/^\s*$/<p>/mg;
# /m 开启增强的行锚点匹配，匹配逻辑行
# 用\s*应对空行可能的空白字符,同时去掉换行符
```

> 补充说明：
> `^`和`$`通常匹配的是字符串的开头和结束位置，而不是逻辑行。(换行符为行结尾)  

### 将E-mail 地址转换为超链接形式

正则框架：

```perl
$text =~ s/\b(username regex\@hostname regex)\b/<a href="mailto:$1">$1<\/a>\g;
# Perl使用@需要转义，当然/也需要转义
```

使用`s{...}{...}`分隔符和`/x`修饰符：
> `/x`只能用于正则，对`replacement`部分无效
> 加上此修饰符后可以使用这样的格式来写正则
<font color="green">书上说用了这种方式分隔就必须折行，啥意思？，还有说Perl是可以自定义分隔符的，这也是自定义吗？定义过程在哪?</font>

```perl
$text =~ s{
       \b
       # 把邮件地址存入变量$1
       (
        username regex # 匹配用户名的正则
        \@
        hostname regex # 匹配主机名的正则
       )
       \b
}{<a href="mailto:$1">$1</a>}gix;
```

#### 匹配用户名(username)

用户名以`\w`开头，后面的部分可以包括点号和连字符  

```regex
\w[-.\w]*
# 确保在字符组内将-放在最开始，以防止其被识别为范围
```

#### 匹配主机名(hostname)

```regex
[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)
```

> 注释：
> 用`\w`不适合，因为有些系统中`\w`可以匹配一些非ASCII字母或者下划线，这些不该出现在主机名。

##### 构建正则表达式库

将正则存在变量中，在其他地方引用  

```perl
$HostnameRegex = qr/[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)/i;
```

### 把HTTP URL 转换为链接形式

HTTP URL　基本形式：`http://hostname/path`

正则框架：

```regex
$text =~ s{
     \b
     # 将URL保存至$1
     (
      http:// hostname
      (
        / path
      )? # /path可选
     )
}{<a href="$1">$1</a>}gix;
# 使用了/x修饰符后正则的空格会省略（像MathJax省略空格一样）
```

#### `/path`部分

```perl
/ [-a-z0-9_:\@&?=+,.!/~*'%\$]*
  (?<![.,?!]                   # 不能以[.,?!]结尾
# 这是放在上面的框架里的，用了/x修饰符所以可以宽松排列
```

> Perl 中`@`和`$`需要转义
> 这里用否定逆序环视来对结尾处进行限制，如用顺序环视则是对开头进行限制

### 综合

```perl
$HostnameRegex = qr/[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)/i;

# 将E-mail地址转换为链接形式
$text =~ s{
    \b
    # 将地址保存至$1
    (
        \w[-.\w]*         # username
        \@
        $HostnameRegex    # hostname
    )
    \b
}{<a href="mailto:$1">$1</a>}gix;

# 将HTTP URL 转换为链接形式
$text =~ s{
    \b
    # 将URL保存至$1
    (
        http:// $HostnameRegex \b            #hostname
        (
            / [-a-z0-9_:\@&?=+,.!/~*'%\$]*   # path不一定出现
              (?<![.,?!])                    # 不以[.,?!]结尾
        )?
    )
}{<a href="$1">$1</a>}gix;
```

> 注意在`$HostnameRegex`后面还有一个单词边界符
> 因为path部分不一定存在，所以在匹配主机名时需要界定结尾

> 关于path的`*`与`?`：
> 可能情况：
> ...hostname/path
> ...hostname/
> ...hostname

## 创建正则表达式库

将正则创建为库以方便在多次使用相同的正则，也便于同时修改。  

### Perl

```perl
$name = qr/regex/modifier;
# name    :正则的名字
# qr      :Perl的操作符，表示接收一个正则
# regex   :要存入的正则
# modifier:修饰符
```
使用方法：直接调用变量$name  
