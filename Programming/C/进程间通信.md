# 进程间通信
## 输入与输出——文件描述符与重定向
### 文件描述符
文件描述符表：  

|  #  | 文件描述符名 | 数据流 |
| :-: | :---------: | :---: |
|  0  |   标准输入   |  键盘  |
|  1  |   标准输出   |  屏幕  |
|  2  |   标准错误   |  屏幕  |
| ... |     ...     |  ...  |

进程用文件描述符表示数据流，将文件描述符和对应的数据流保存在描述符表中。  
文件描述符对应的数据流不一定是文件，可能是设备、文件指针、网络。  
描述符表的前三项不变，其他项为空或连接进程打开的数据流。  
创建进程后，前三项与数据流的连接不变，直到被重定向修改。  
描述符表大小：0-255  

### 重定向—替换文件描述符连接的数据流
标准输入/输出/错误在描述符表中的位置固定(0,1,2)，但连接的数据流可以改变。  

#### 重定向运算符
##### >
重定向到的数据流内容将先被清空。  

###### 标准输出重定向
```
/* 将标准输出重定向到文件 */
/* 下面两句效果相同 */
ls > out_ls.txt
ls 1> out_ls.txt
```
描述符表中修改：  

|  #  | 文件描述符名 |          数据流          |
| :-: | :---------: | :---------------------: |
|  0  |   标准输入   |           键盘           |
|  1  |   标准输出   | ~~屏幕~~(out_ls.txt文件) |
|  2  |   标准错误   |           屏幕           |
| ... |     ...     |           ...           |

###### 标准错误重定向
使用标准错误的文件描述符。  
```
/* 将标准错误重定向到文件 */
ls 2> err_ls.txt
```

描述符表中修改：  

|  #  | 文件描述符名 | 数据流 |
| :-: | :---------: | :---: |
|  0  |   标准输入   |  键盘  |
|  1  |   标准输出   |  屏幕  |
|  2  |   标准错误   |  ~~屏幕~~ (err_ls.txt文件)  |
| ... |     ...     |  ...  |

在类Unix系统中，可以用下面命令将标准错误重定向到标准输出。  
```
ls 2>&1
2> ：重定向标准错误
&1 ：到标准输出
```
##### <
```
get_input < input.txt
/* 将标准输入重定向为文件 */
```

##### >>
差别在于会以追加模式进行重定向。  

#### 操作文件描述符表的函数
##### fileno()——返回文件描述符
头文件：stdio.h  
每打开一个文件，操作系统会在描述符表中新注册一项，可使用fileno()用文件指针得到描述符。  
>例：打开文件guitar.mp3后描述符表的情况
>```c
>FILE * my_file = fopen("guitar.mp3, "r");
>```
>|  #  |     数据流     |
>| :-: | :------------: |
>| 略  |       略       |
>|  3  |   数据库连接    |
>|  4  | guitar.mp3文件 |
>| 略  |       略       |
>```c
>fileno(my_file); //将返回4
>```

##### dup2()——复制数据流
头文件：unistd.h  
可以复制描述符的数据流到另一个描述符。  
>例：描述符表见上
>```c
>dup2(4, 3);
>/* 把4号描述符的数据流复制到3号描述符 */
>```
>|  #  |            数据流            |
>| :-: | :-------------------------: |
>| 略  |              略              |
>|  3  | ~~数据库连接~~ guitar.mp3文件 |
>|  4  |        guitar.mp3文件        |
>| 略  |              略              |

##### 使用相关
对标准输出重定向后，使用标准输出的函数输出内容将在文件头部开始添加内容。  
<font color='green'>*//输出内容的顺序不会变，只是整体都在原内容前*</font>
<font color='orange'>还会把原内容删掉？</font>

## 实时连接两个进程——管道
### 命令行
```
使用竖线(|)连接程序
```
>例：执行output程序将输出一些单词和链接，使用管道命令和grep命令来过滤出链接
>```
>$ ./output | grep 'http'
>```
>幕后：
>
>1. 命令行创建了父进程
>[ ]
>2. 父进程在子进程中克隆出了output程序
>[ ] -> [output]
>3. 父进程用管道把子进程的输出连接到了自己的输入
>[ ]<---[output]
>4. 父进程运行了grep命令
>[grep]<---[output]

### 函数
#### pipe()
<font color='orange'>好像只能用于父子进程</font>  
头文件：unistd.h  
pipe()会创建两条相连的数据流，并把它们加到文件描述符表中。  
pipe()需要接受一个两个int元素的数组，用以存放文件描述符。  
第一个元素为读管道，第二个元素为写管道。  
>例：fd[0]：读管道；fd[1]：写管道
>```c
>int fd[2];
>if (pipe(fd) == -1)
>    error("Can't create the pipe");
> /* error()函数详情见“进程与系统调用/exit()” */
>```

##### 子进程要做的
情况：子进程对父进程发送消息。  
具体行为根据情况修改。  
关闭读取端，打开写入端，把写入端连接到标准输出。  
```c
close(fd[0]);
dup2(fd[1], 1);
```

##### 父进程要做的
情况：子进程对父进程发送消息。  
具体行为根据情况修改。  
关闭写入端，打开读取端，把读取端连接到标准输入。  
```c
close(fd[1]);
dup2(fd[0], 0);
```

#### mkfifo()
可以创建基于文件的有名管道(FIFO, First In First Out)。  
有名管道可以让非父子关系的进程通信。  
<font color='green'>*//pipe()创建的管道通常用存储器实现。*</font>

## 相互等待
### waitpid()
头文件：sys/wait.h  
```c
/* 原型: */
pid_t waitpid(pid_t pid, int * status, int options);
/* 一般的使用方式 */
if (waitpid(pid, &pid_status, 0) == -1)
{
    fprintf(stderr, "等待子进程时发生了错误\n");
    exit(1);
}
```
* pid
    要等待的进程的PID。  
    可以使用fork()返回的值。  
* status
    函数结束等待时会在此变量中保存一个值，表示进程的完成状态。  
    可以把此变量传给WEXITSTATUS()宏获取前八位的退出状态。  
    <font color='green'>//退出状态不是0时宏会返回真值</font>  
* options
    * 0：等待进程结束。  

## 信号
信号是一个整型值，信号到来时进程必须先处理信号。  
进程会查看信号映射表，每个信号对应一个信号处理函数。  
<font color='green'>*//中断信号(Ctrl+C)的默认信号处理函数是exit()*</font>  

### 捕获信号并运行自己的代码
#### 编写信号处理器函数
* 信号是一个整型值，所以函数必须接受一个整型参数。  
    >函数头部示例：
    >```c
    >void example(int sig)
    >```
* <font style='background: yellow'>处理器函数中使用标准输出和标准错误要注意：</font>  
    产生信号->有故障->无法使用标准输出和标准错误。  

处理器函数的代码应该短而快，刚好能处理接收的信号就好。  

#### 注册信号处理器函数
<font color='green'>*//使用sigaction()而不是signal()是因为移植性更好*</font>  

##### 创建sigaction类型结构变量
头文件：signal.h  
使用sigaction结构模板创建结构来包装函数成为处理器函数。  

>例：创建名为action的结构变量包装diediedie()函数
>```c
>struct sigaction action; //创建新动作
>action.sa_handler = diediedie; //设置函数
>sigemptyset(&sa_mask); //使用空掩码过滤要处理的信号(啥意思不懂,怎么过滤)
>action.sa_flags = 0;   //附加标准位，设为0就行(所以这啥)
>```

##### 使用sigaction()注册结构变量
头文件：signal.h  
```c
/* 调用 */
sigaction(signal_no, &new_action, &old_action);
```
* `signal_no`，信号编号
    希望处理的信号。  

    |   信号   | 原因                                            |
    | :------: | :--------------------------------------------- |
    |  SIGINT  | 进程被中断(Ctrl+C)                              |
    | SIGQUIT  | 有人要求终止进程，并把存储器的内容保存到核心转储文件 |
    |  SIGFPE  | 浮点错误                                        |
    | SIGTRAP  | 调试人员询问进程执行到了哪里                      |
    | SIGSEGV  | 进程企图访问非法存储器地址                        |
    | SIGWINCH | 终端窗口的大小发生改变                            |
    | SIGTERM  | 有人要求内核终止进程                             |
    | SIGPIPE  | 进程在向一个没有人读的管道写数据                   |
    | SIGALRM  | 通过调用alarm()发出                              |
    <font color='green'>*//此表为程序可捕获到的信号，关于发送信号看下面(还有些无法捕获的信号*</font>  
* `&new_action`，新动作
    想注册的新sigaction类型结构变量的地址。  
* `&old_action`，旧动作
    会将被替换掉的信号处理器保存在此结构，不想保存设为NULL。  

如果函数失败会返回`-1`，并设置errno变量。  

##### 将注册操作包装成一个函数
```c
/* 将函数设置为给定信号的处理器 */
/* 调用方式: catch_signal(要处理的信号, 用来处理的函数名); */
int catch_signal(int sig, void (*handler)(int))
{
    struct sigaction action;
    action.sa_handler = handler;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    return sigaction(sig, &action, NULL);
}
```

#### 重置(恢复默认)&忽略信号处理函数
创建sigaction类型结构变量时，函数设置为**signal.h**里的`SIG_DFL`或`SIG_IGN`。  
```c
catch_signal(信号, SIG_DFL); //恢复默认的信号处理
catch_signal(信号, SIG_IGN); //忽略信号
```

### 发出信号
#### kill命令
```
列出所有信号：$kill -l
向进程发送SIGTERM信号：$kill PID
向程序发送SIGINT 信号：$kill -INT PID
向程序发送SIGSEGV信号：$kill -SEGV PID
向程序发送SIGKILL信号：$kill -KILL PID
向程序发送SIGSTOP信号：$kill -STOP PID
```
`SIGKILL`信号程序无法忽略，会强制结束程序。  
`SIGSTOP`信号程序无法忽略，会暂停程序。  

#### raise()
头文件：signal.h  
进程可以用此函数向自己发信号。  
```c
raise(信号);
```
**信号升级**
在接收到低级别的信号时引发更高级别的信号。  

#### alarm()闹钟函数
##### 使用
头文件：unistd.h  
可延时发送`SIGALRM`信号。  
```c
/* 原型 */
unsigned int alarm(unsigned int seconds);
```
seconds：指定的秒数。  
<font color='green'>*//需要更精确的定时可以使用setitimer()*</font>  

##### 注意
一个进程只能有一个闹钟时间，所以重复调用此函数会覆盖上一次调用的时间。  
同时使用alarm()和sleep()会发生冲突。  




