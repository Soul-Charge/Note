vnote_backup_file_826537664 D:/other/VNote/Note/Programming/C/进程间通信.md
# 进程间通信
## 输入与输出——文件描述符与重定向
### 文件描述符
文件描述符表：  

|  #  | 文件描述符名 | 数据流 |
| :-: | :---------: | :---: |
|  0  |   标准输入   |  键盘  |
|  1  |   标准输出   |  屏幕  |
|  2  |   标准错误   |  屏幕  |
| ... |     ...     |  ...  |

进程用文件描述符表示数据流，将文件描述符和对应的数据流保存在描述符表中。  
文件描述符对应的数据流不一定是文件，可能是设备、文件指针、网络。  
描述符表的前三项不变，其他项为空或连接进程打开的数据流。  
创建进程后，前三项与数据流的连接不变，直到被重定向修改。  
描述符表大小：0-255  

### 重定向—替换文件描述符连接的数据流
标准输入/输出/错误在描述符表中的位置固定(0,1,2)，但连接的数据流可以改变。  

#### 重定向运算符
##### >
重定向到的数据流内容将先被清空。  

###### 标准输出重定向
```
/* 将标准输出重定向到文件 */
/* 下面两句效果相同 */
ls > out_ls.txt
ls 1> out_ls.txt
```
描述符表中修改：  

|  #  | 文件描述符名 |          数据流          |
| :-: | :---------: | :---------------------: |
|  0  |   标准输入   |           键盘           |
|  1  |   标准输出   | ~~屏幕~~(out_ls.txt文件) |
|  2  |   标准错误   |           屏幕           |
| ... |     ...     |           ...           |

###### 标准错误重定向
使用标准错误的文件描述符。  
```
/* 将标准错误重定向到文件 */
ls 2> err_ls.txt
```

描述符表中修改：  

|  #  | 文件描述符名 | 数据流 |
| :-: | :---------: | :---: |
|  0  |   标准输入   |  键盘  |
|  1  |   标准输出   |  屏幕  |
|  2  |   标准错误   |  ~~屏幕~~ (err_ls.txt文件)  |
| ... |     ...     |  ...  |

在类Unix系统中，可以用下面命令将标准错误重定向到标准输出。  
```
ls 2>&1
2> ：重定向标准错误
&1 ：到标准输出
```
##### <
```
get_input < input.txt
/* 将标准输入重定向为文件 */
```

##### >>
差别在于会以追加模式进行重定向。  

#### 操作文件描述符表的函数
##### fileno()——返回文件描述符
头文件：stdio.h  
每打开一个文件，操作系统会在描述符表中新注册一项，可使用fileno()用文件指针得到描述符。  
>例：打开文件guitar.mp3后描述符表的情况
>```c
>FILE * my_file = fopen("guitar.mp3, "r");
>```
>|  #  |     数据流     |
>| :-: | :------------: |
>| 略  |       略       |
>|  3  |   数据库连接    |
>|  4  | guitar.mp3文件 |
>| 略  |       略       |
>```c
>fileno(my_file); //将返回4
>```

##### dup2()——复制数据流
头文件：unistd.h  
可以复制描述符的数据流到另一个描述符。  
>例：描述符表见上
>```c
>dup2(4, 3);
>/* 把4号描述符的数据流复制到3号描述符 */
>```
>|  #  |            数据流            |
>| :-: | :-------------------------: |
>| 略  |              略              |
>|  3  | ~~数据库连接~~ guitar.mp3文件 |
>|  4  |        guitar.mp3文件        |
>| 略  |              略              |

##### 使用相关
对标准输出重定向后，使用标准输出的函数输出内容将在文件头部开始添加内容。  
<font color='green'>*//输出内容的顺序不会变，只是整体都在原内容前*</font>
<font color='orange'>还会把原内容删掉？</font>

## 实时连接两个进程——管道
### 命令行
```
使用竖线(|)连接程序
```
>例：执行output程序将输出一些单词和链接，使用管道命令和grep命令来过滤出链接
>```
>$ ./output | grep 'http'
>```
>幕后：
>
>1. 命令行创建了父进程
>[ ]
>2. 父进程在子进程中克隆出了output程序
>[ ] -> [output]
>3. 父进程用管道把子进程的输出连接到了自己的输入
>[ ]<---[output]
>4. 父进程运行了grep命令
>[grep]<---[output]

### 函数
#### pipe()
<font color='orange'>好像只能用于父子进程</font>  
头文件：unistd.h  
pipe()会创建两条相连的数据流，并把它们加到文件描述符表中。  
pipe()需要接受一个两个int元素的数组，用以存放文件描述符。  
第一个元素为读管道，第二个元素为写管道。  
>例：fd[0]：读管道；fd[1]：写管道
>```c
>int fd[2];
>if (pipe(fd) == -1)
>    error("Can't create the pipe");
> /* error()函数详情见“进程与系统调用/exit()” */
>```

##### 子进程要做的
情况：子进程对父进程发送消息。  
具体行为根据情况修改。  
关闭读取端，打开写入端，把写入端连接到标准输出。  
```c
close(fd[0]);
dup2(fd[1], 1);
```

##### 父进程要做的
情况：子进程对父进程发送消息。  
具体行为根据情况修改。  
关闭写入端，打开读取端，把读取端连接到标准输入。  
```c
close(fd[1]);
dup2(fd[0], 0);
```

#### mkfifo()
可以创建有名管道。  


## 相互等待
### waitpid()
头文件：sys/wait.h  
```c
/* 原型: */
pid_t waitpid(pid_t pid, int * status, int options);
/* 一般的使用方式 */
if (waitpid(pid, &pid_status, 0) == -1)
{
    fprintf(stderr, "等待子进程时发生了错误\n");
    exit(1);
}
```
* pid
    要等待的进程的PID。  
    可以使用fork()返回的值。  
* status
    函数结束等待时会在此变量中保存一个值，表示进程的完成状态。  
    可以把此变量传给WEXITSTATUS()宏获取前八位的退出状态。  
    <font color='green'>//退出状态不是0时宏会返回真值</font>  
* options
    * 0：等待进程结束。  







